<html>
<head>
<script src="tinytest.js"></script>
</head>

<body>

<div style="display:none"><input id="token"/></div>

<!-- this duplicates hlib.setUser because forms created in tests can't see the module -->
<script>
  function setUser() {
    let value = document.getElementById('userForm').value;
    localStorage.setItem('h_user', value); 
}
</script>

 <!-- This module syntax is so convenient... -->
<script type="module">  

// Because with this import method...
import * as hlib from './hlib.js'
// ... I can debug the library, which uses export statements, directly. 

// For deployed apps based on this library, the pattern so far is:
//  - bundle as hlib.bundle.js
//  - run webpack
//  - use devtool to produce a source map
//  - use source-map-loader to load the source map
// It will be nice when all that nonsense goes away.

let scratchUri = 'https://jonudell.net/h/scratch.html'
let scratchQuote = 'First para'
let scratchText = 'hlib test'
let testAnnotation = 'M48i_AAkEemMqAtMSK82kg'

function delay(seconds) {
  return new Promise( resolve => setTimeout(resolve, seconds * 1000))
}

async function waitSeconds(seconds, data) {
  await delay(seconds)
  return data
  }

function appendBody(element) {
  document.body.appendChild(element)
}

function createGroupContainer() {
  let groupContainer = document.createElement('div');
  groupContainer.id = 'groupContainer';
  document.body.append(groupContainer);
  return groupContainer;
}

function removeGroupContainer() {
  let groupContainer = hlib.getById('groupContainer')
  if (groupContainer) {
    groupContainer.remove()
  }
}

function checkAndDeleteTestAnnotation(data, token) {
  return new Promise(resolve => {
    let response = JSON.parse(data.response)
    if (response.target[0].selector) {
      let selectors = hlib.parseSelectors(response.target)
      eq(selectors.TextQuote.exact, scratchQuote)
      let annotation = hlib.parseAnnotation(response)
      eq(annotation.quote, scratchQuote)
    }
    assert(response.id)
    assert(response.updated)
    hlib.deleteAnnotation(response.id, token)
     .then(data => {
        console.log('deleted test annotation', data)
        resolve()
     })
  })
}

tests({

'gets token': function () {
  return new Promise(resolve => {
   let token = hlib.getToken()
   let slice = token.slice(0,9)
   eq(slice, '6879-358c')
   resolve()
  })
 },

'gets "" when no user': function() {
  return new Promise(resolve => {
    delete localStorage['h_user']
    let user = hlib.getUser()
    eq(user, "")
    resolve()
   })
  },

'username input form saves and retrieves value': function() {
  return new Promise(resolve => {
   let formElement = document.createElement('div')
   let args = {
     element: formElement,
     name: 'Hypothesis username',
     id: 'user',
     value: '',
     onchange: 'setUser',
     type: '',
     msg: ''
   }
   let form = hlib.createNamedInputForm(args)
   appendBody(form)
   let inputElement = hlib.getById('userForm')
   inputElement.value = 'judell'
   let evt = document.createEvent("HTMLEvents")
   evt.initEvent("change", false, true)
   inputElement.dispatchEvent(evt)
   eq(hlib.getUser(), 'judell')
   delete localStorage['h_user']
   form.remove()
   resolve()
  })
 }, 

'creates facet input form': function() {
  return new Promise(resolve => {
   let formElement = document.createElement('div')
   let args = {
     element: formElement,
     name: 'tag',
     id: 'tag',
     value: '',
     onchange: '',
     type: '',
     msg: ''
   }
   let form = hlib.createFacetInputForm(formElement, 'tag', 'hypothesis tag')
   appendBody(form)
   let inputElement = hlib.getById('tagForm')
   inputElement.value = 'tag'
   eq(document.getElementsByClassName('tagForm')[0].innerHTML, '<input id="tagForm">')
   form.remove()
   resolve()
  })
 },

'creates default group picklist with > 1 groups when token': function() {
  return new Promise(resolve => {
   let groupContainer = createGroupContainer()
   let defaultSelectId = 'groupsList'
   hlib.createGroupInputForm(groupContainer)
   waitSeconds(1)
     .then( r => {
       let groupList = hlib.getById(defaultSelectId)
       assert(groupList)
       let options = groupList.querySelectorAll('option')
       assert(groupList.length > 1)
       eq(hlib.getSelectedGroup(defaultSelectId), '__world__')
       removeGroupContainer()
       resolve()
     })
    })
 },

'creates custom group picklist with > 1 groups when token': function() {
   return new Promise(resolve => {
    let selectId = 'withTokenGroupsList'
    let groupContainer = createGroupContainer()
    hlib.createGroupInputForm(groupContainer, selectId)
    waitSeconds(1)
      .then( r => {
        let groupList = hlib.getById(selectId)
        assert(groupList)
        let options = groupList.querySelectorAll('option')
        assert(groupList.length > 1)
        eq(hlib.getSelectedGroup(selectId), '__world__') 
        removeGroupContainer()
        resolve()
      })
    })
 },

'creates group picklist with 1 group when no token': function() {
  return new Promise(resolve => {
    let token = hlib.getToken()
    hlib.getById('token').setAttribute('value',token)
    delete localStorage['h_token']
    let groupContainer = createGroupContainer()
    hlib.createGroupInputForm(groupContainer)
    waitSeconds(1)
      .then( r => {
        localStorage['h_token'] = hlib.getById('token').value  // not in effect for subsequent tests
        let groupList = hlib.getById('groupsList')
        assert(groupList)
        let options = groupList.querySelectorAll('option')
        assert(groupList.length == 1, `expected 1, got ${groupList.length}`)
        eq(hlib.getSelectedGroup(), '__world__')
        removeGroupContainer()
        resolve()
      })
    })
 },

'creates a pagenote': function() {
   return new Promise(resolve => {
    let token = hlib.getById('token').value
    let params = {
      uri: scratchUri,
      group: '__world__',
      text: scratchText,
    }
    let payload = hlib.createAnnotationPayload(params)
    hlib.postAnnotation(payload, token)
      .then(data => {
        waitSeconds(1, data)
          .then(data => {
            checkAndDeleteTestAnnotation(data, token)
              .then( _ => {
                resolve()
              })
          })
      })
    })
 },

'creates an annotation': function() {
   return new Promise(resolve => {
    let token = hlib.getById('token').value
    let params = {
      uri: scratchUri,
      group: '__world__',
      text: scratchText,
      exact: scratchQuote,
    }
    let payload = hlib.createAnnotationPayload(params)
    hlib.postAnnotation(payload, token)
      .then(data => {
        waitSeconds(1, data)
          .then(data => {
            checkAndDeleteTestAnnotation(data, token)
              .then( _ => {
                resolve()
              })
          })
      })
    })
 },

'finds a test annotation': function() {
  return new Promise(resolve => {
    let token = hlib.getById('token').value
    let params = {
      user: 'judell',
      tag: 'hlibtest',
    }
    hlib.search(params)
      .then (data => {
        let [annos, replies] = data
        assert(annos.length)
        eq(hlib.parseAnnotation(annos[0]).id, testAnnotation)
        resolve()
      })
   })
 },

 'fails to retrieve from wrong service': function() {
   return new Promise(resolve => {
    hlib.updateSettings({service: 'https://WrongService'})
     let params = {}
     hlib.search(params) // the api request should fail 
      .catch (data => {
        hlib.updateSettings({service: 'https://hypothes.is'})
        resolve()
      })
   })
 },

'retrieves 600 annotations': function() {
  return new Promise(resolve => {
    function callback(annos, replies) {
      eq(annos.length, 600)
      resolve()
    }
    let token = hlib.getById('token').value
    let params = {
      max: 600,
    }
    hlib.hApiSearch(params, callback)
   })
 },

'uses wildcard uris': function() {
  return new Promise(resolve => {
    function callback(annos, replies) {
    }
    let token = hlib.getById('token').value
    let params = {
      wildcard_uri: 'https://web.hypothes.is/*',
      max: 400
    }
    hlib.search(params)
    .then ( data => {
      let annos = data[1]
      let uris = annos.map(a => { return a.uri })
      let blogUris = uris.map(u => u.startsWith('https://web.hypothes.is/blog')).filter(x => {return x})
      assert(blogUris.length > 1)
      let faqUris = uris.map(u => u.startsWith('https://web.hypothes.is/faq')).filter(x => {return x})
      assert(faqUris.length > 1)
      resolve()
    })
   })
 },

})

</script>

<div id="log"></div>

</body>
</html>